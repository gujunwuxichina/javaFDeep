package com.gujun.Threads;

public class Basic02 {

    //线程生命周期：当线程被创建启动后，它不是就立即进入执行状态，也不会一直处于执行状态；
    //新建和就绪状态：
    //当通过new创建一个线程后，该线程就处于新建状态，此时它和其它Java对象一样，仅仅由JVM为其分配内存，初始化成员变量的值，没有表现出线程的动态特征；
    //当调用了线程的start()后，就处于就绪状态，JVM会为其创建方法调用栈和程序计数器，此时线程并没有执行，只是表示线程可以执行，至于何时执行，取决于JVM的调度；
    //运行和阻塞状态：
    //若处于就绪状态的线程获得了CPU，就开始执行线程执行体，此时线程处于运行状态；
    //当一个线程运行后，不可能一直处于运行状态，在其运行过程中需要被中断，让其它线程获得执行机会；至于如何调度取决于底层所采用的策略；
    //抢占式策略，系统给每个线程一小段时间来执行，时间用完后系统就会剥夺该线程所占用的资源，让其他线程获得执行机会（如何选择其它线程，会考虑线程的优先级）；
    //一些手机设备可能会采用协作式策略，此时只有当线程主动调用sleep()或yield()才会放弃所占用的资源；
    //如下情况，线程将会进入阻塞状态：
    //1.线程调用sleep()主动放弃占用的资源；
    //2.线程调用了一个阻塞式IO方法，在该方法返回之前，线程被阻塞；
    //3.线程试图获得一个同步监听器，但该同步监听器正被其它线程所持有；
    //4.线程在等待某个通知notify;
    //5.调用了线程的suspend()将该线程挂起，该方法容易导致死锁，不推荐；
    //当正在执行的线程被阻塞后，其它线程就获得了执行的机会；被阻塞的线程会在合适的时候重新进入就绪状态；
    //对于上面的情况，发生如下情况可以接触阻塞状态进入就绪状态：
    //1.调用sleep()线程经过了指定时间；
    //2.线程调用的阻塞是IO方法已经返回；
    //3.线程成功获取了试图取得的同步监听器；
    //4.线程正在等待通知时，其他线程发出了一个通知；
    //5.处于挂起状态的线程被调用了resume()恢复；
    //阻塞状态只能进入就绪状态，无法直接进入运行状态，就绪和运行状态可以直接转换；
    //线程死亡：
    //线程会以如下三种方式结束，结束后就处于死亡状态：
    //1.run()或call()执行完，结束后就处于死亡状态；
    //2.线程抛出一个未捕获的异常；
    //3.直接调用线程的stop()结束线程，容易造成死锁，不推荐；
    //tip:当主线程结束时，其他线程不受任何影响，并不会随之结束；一旦子线程启动后，就拥有和主线程相同的地位，不受主线程影响；
    //isAlive(),当线程处于就绪、运行、阻塞时返回true,处于新建、死亡时返回false;

}

package com.gujun.se;

/**
 * @ClassName gu
 * @Description TODO
 * @Author GuJun
 * @Date 2019/4/18 21:12
 * @Version 1.0
 **/
public class CleanObject {
    //ThinkInJava
    //如果对象不是使用new来获取的内存区域，由于垃圾回收器只知道释放那些由new分配的内存；所以不知道该如何释放这些内存；
    //为此在类中定义了finalize()，原理是一旦垃圾回收器准备释放对象占用的存储空间，将首先调用其finalize()，在下一次垃圾回收发生时，才会真正回收内存；
    //finalize并等同于C++中的析构函数，C++中销毁对象必须调用该函数，C++中对象一定会被销毁，而Java中不一定；
    //Java并未提供类似析构函数，必须自己动手创建一个执行清理工作的普通方法
    //如：某个对象必须进行某些清理操作后才能得到回收，如果不进行这些清理操作永远得不到回收；
    //此时就可以在finalize()中加入这样的清理操作，当垃圾回收器准备工作时（不一定发生），finalize()得到调用，对象得到回收，
    //垃圾回收器不工作则对象一直存在；
    //不该将finalize()作为通用的清理方法，finalize()用途：
    //垃圾回收只与内存有关，使用垃圾回收器的唯一原因就是为了回收程序不再使用的内存；
    //对finalize()的需求限制到一种特殊情况，即通过某种创建对象以外的方式为对象分配内存；
    //该分配内存的方式如采用了C的做法（malloc()则必须free()），主要发生在使用本地方法（本地方法是一种在Java中调用非Java代码的方式）
    //需要在finalize()中调用本地方法；
    //Java中不允许创建局部对象；Java中没有用于主动释放对象的方法；垃圾回收器会处理这些（工作前调用对象的finalize()）；
    //但是垃圾回收器并不能完全代替析构函数；
    //对于对象回收前的清理工作，必须创建其他清理方法，并明确调用它们；(则finalize()只能存在于本地方法了)
    //finalize()并不依赖于每次都要对finalize()进行调用,这就为对象的终结创造了验证条件；
    //如：某个对象当应该被处理时，应该处于某种状态才行，此时可以用finalize()来验证是否处于该状态；

    //Crazy Java
    //在垃圾回收机制回收任何对象之前，总会先调用它的finalize()，该方法可能会是该对象复活(即被新的引用变量指向)，从而导致垃圾回收机制取消；
    //对象在内存中的状态：1.可达状态，创建后被变量引用；2.可恢复状态，没有变量引用，还没调用调用finalize()；3.调用finalize()后，还是没有被引用，则可以被垃圾回收器回收；
    //一个对象可以被局部变量、类变量、实例变量引用；
    //强制垃圾回收：
    //当一个对象失去引用后，系统何时调用其finalize()准备进行垃圾回收，系统何时回收内存，完全透明；
    //可以强制通知系统进行垃圾回收，但是只是通知，一般通知都有效果；
    //1.System.gc();2.Runtime.getRuntime().gc();3.System.runFinalization()/Runtime.getRuntime.runFinalization()；
    //finalize():
    //任何Java类都可以重写finalize()；如果程序终止前始终没有进行垃圾回收，则不会调用失去引用的对象的finalize();
    //特点：1.永远不要主动调用finalize()，交给垃圾回收器调用；2.何时调用不确定性；3.finalize()出现异常，垃圾回收器不会报告，程序继续执行；

    //Think in Java
    //垃圾回收器工作：
    //一些其他语言在堆上分配对象代价高，但是Java在堆上分配内存的速度可以和一些其他语言在栈上分配速度相媲美；
    //这是由于垃圾回收器能提高对象的创建速度，存储空间的释放会影响存储空间的分配，这是某些Java虚拟机的工作方式；

}

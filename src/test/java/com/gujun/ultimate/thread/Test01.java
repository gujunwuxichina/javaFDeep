package com.gujun.ultimate.thread;

/**
 * @ClassName: Test01
 * @Author GuJun
 * @Description:
 * @Date 2021年07月31日 10:47
 */
public class Test01 {

    //  线程概述
    //  每个运行中的程序就是一个进程，每个程序中可能包含多个顺序执行流，每个顺序执行流就是一个线程；
    //  并发，指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换进行，使得好像同时进行；
    //  并行，指同一时刻多个进程指令在多个在多个处理器上同时执行；

    //  线程的创建和启动
    //  Thread类代表线程类，线程对象必须是Thread类或其子类；
    //  实现Runnable接口创建线程；
    //  使用Callable和Future创建线程：
    //  Callable接口提供一个call()来作为线程执行体；call()可以有返回值；
    //  Callable接口不是Runnable的子接口，所以不能直接作为Thread的target;
    //  为此提供了Future接口，其代表call()的返回值；Future接口实现类FutureTask实现类，也实现了Runnable接口；
    //  Future接口方法：get()，isCancelled(),idDone()...;
    //  使用FutureTask来包装Callable对象，作为Thread的target;

    //  线程的生命周期
    //  当线程启动后，并不是一启动就进入执行状态的，也不会一直处于执行状态；
    //  线程会经历新建，就绪，运行，阻塞，死亡；
    //  阻塞
    //  当线程被阻塞后，其它线程就获得了执行的机会；被阻塞的线程会在合适的时候重新进入就绪状态；
    //  线程进入阻塞：
    //  1.线程调用sleep()；
    //  2.线程调用一个阻塞式IO,在该方法返回之前，线程被阻塞；
    //  3.线程试图获取一个同步监视器，但该同步监视器被其它线程占用；
    //  4.线程在等待某个notify;
    //  5.程序调用了线程的suspend()，将该线程挂起；不推荐，容易导致死锁；
    //  阻塞的线程进入就绪状态：
    //  1.调用sleep()的线程经过了指定时间；
    //  2.线程调用的阻塞式IO方法返回了；
    //  3.线程成功获取同步监视器；
    //  4.线程等待的通知，其它线程发出了该通知；
    //  5.处于挂起的线程调用了resume();
    //  线程死亡
    //  1.线程执行体执行完；
    //  2.线程抛出一个未捕获的异常或Error；
    //  3.调用线程stop();不推荐；
    //  子线程不受主线程结束的影响；
    //  isAlive(),处于就绪，运行，阻塞返回true;新建，死亡返回false;


}
